<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Yin-Chiuan Chen</title><link>https://leovincentseles.github.io/post/</link><description>Recent content in Posts on Yin-Chiuan Chen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 30 Jan 2022 18:15:41 +0800</lastBuildDate><atom:link href="https://leovincentseles.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Binary Search</title><link>https://leovincentseles.github.io/posts/binary-search/</link><pubDate>Sun, 30 Jan 2022 18:15:41 +0800</pubDate><guid>https://leovincentseles.github.io/posts/binary-search/</guid><description>介紹 二元搜索法 (Binary Search) 是大家剛接觸程式設計就學習到的演算法，但是一點也不簡單，是標準的一看就會一寫就廢類型 (引自代碼隨想錄)，寫不好的原因有兩個 區間的定義 [left, right], [left, right), (left, right], (left, right) left, right 兩個索引在算法執行前、執行中與執行後後分別會指向哪種元素? 這篇文章將會描述二元搜索法的算法模板，以及介紹三種常見的二元搜索法問題 基本模板 模板是讀了jiah在Leetcode討論區下方的留言之後整理出來 先討論二元搜索法的基本模板，後續才會說明如何利用模板轉換成三種常見的二元搜索法問題 基本模板說明 目標: 給定一個陣列arr，找出最小的索引k，使得condition(arr[k])結果為true。
舉個例子: 找出陣列中第一個大於等於6的元素，
用基本模板說明就是找出陣列中最小的索引k，而且arr[k] ≥ 6 (condition函數)
在這個例子(下方程式碼)中我們想要的k就是2 (因為arr[2] ≥ 6)
1 2 3 4 5 6 7 // The given array vector&amp;lt;int&amp;gt; arr{1, 5, 7, 20}; // The condition function bool condition(int val) { return (val &amp;gt;= 6); } 在更深入討論基本模板之前，我們需要先了解模板的使用前提，並設計適當的condition函數</description></item><item><title>STL</title><link>https://leovincentseles.github.io/posts/stl/</link><pubDate>Sun, 30 Jan 2022 10:17:40 +0800</pubDate><guid>https://leovincentseles.github.io/posts/stl/</guid><description>C++ STL queue priority_queue stack vector insert back N/A N/A N/A push_back O(1) amortized Insertion push O(1) push O(logN) push O(1) insert O(#inserted + #after) Emplace emplace O(1) emplace O(logN) emplace O(1) emplace O(#after) Deletion pop O(1) pop O(logN) pop O(1) erase O(#erased + #after) Get Frist front O(1) top O(1) N/A front O(1) Get Last back O(1) N/A top O(1) back O(1) Is Empty empty O(1) empty O(1) empty O(1) empty O(1) Size size O(1) size O(1) size O(1) size O(1) Clear N/A N/A N/A clear O(N) set unordered_set Count count O(logN) count O(1) avg O(N) worst Insert insert O(logN) insert O(1) avg O(N) worst May rehash Emplace emplace O(logN) emplace O(1) avg O(N) worst May rehash Deletion (val) erase O(logN) erase O(1) avg O(N) worst Deletion (iterator) erase O(1) amortized erase O(1) Deletion (range) erase O(#erased) erase O(#erased) Find find O(logN) find O(1) avg O(N) worst Lower_bound lower_bound O(logN) N/A Upper_bound upper_bound O(logN) N/A Clear clear O(N) clear O(N) deque Implementation: matains a double-ended queue of chunks of fixed size.</description></item></channel></rss>