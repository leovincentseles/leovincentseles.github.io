[{"content":"介紹  二元搜索法 (Binary Search) 是大家剛接觸程式設計就學習到的演算法，但是一點也不簡單，是標準的一看就會一寫就廢類型 (引自代碼隨想錄)，寫不好的原因有兩個  區間的定義  [left, right], [left, right), (left, right], (left, right)   left, right 兩個索引在算法執行前、執行中與執行後後分別會指向哪種元素?   這篇文章將會描述二元搜索法的算法模板，以及介紹三種常見的二元搜索法問題  基本模板  模板是讀了jiah在Leetcode討論區下方的留言之後整理出來 先討論二元搜索法的基本模板，後續才會說明如何利用模板轉換成三種常見的二元搜索法問題  基本模板說明  目標: 給定一個陣列arr，找出最小的索引k，使得condition(arr[k])結果為true。\n   舉個例子: 找出陣列中第一個大於等於6的元素，\n  用基本模板說明就是找出陣列中最小的索引k，而且arr[k] ≥ 6 (condition函數)\n  在這個例子(下方程式碼)中我們想要的k就是2 (因為arr[2] ≥ 6)\n1 2 3 4 5 6 7  // The given array vector\u0026lt;int\u0026gt; arr{1, 5, 7, 20}; // The condition function bool condition(int val) { return (val \u0026gt;= 6); }       在更深入討論基本模板之前，我們需要先了解模板的使用前提，並設計適當的condition函數\n 前提: 調用condition函數後所有true發生的位置必須落在所有false的右邊 合法的情形  (前半部為false, 後半部為true)，false, false, false, true, true, true (全為false)，false, false, false, false, false, false (全為true)，true, true, true, true, true, true   不合法的情形: 有的true出現在false左邊  false, true, false, true, true      循環不變量  實作二元搜索法之前，我們先定義一些循環不變量(Loop Invariants)，執行前、執行中與執行後我們都需要遵守這些循環不變量的規則 為了避免複雜的邊界條件，我們將陣列索引範圍從原本的 \\([0, arr.size())\\)想像往左和右擴展至\\((-\\infty, +\\infty)\\)，同時也要符合前提: 調用condition函數後所有true發生的位置必須落在所有false的右邊，也就是  擴展的陣列索引\\((-\\infty,\\ 0)\\) 皆無法滿足condition函數(false) 擴展的陣列索引\\([arr.size(),\\ +\\infty)\\) 皆滿足condition函數(true)   接著定義三個循環不變量(待檢測集合、false集合與true集合) index \\(\\in [left,\\ right)\\) → 待檢測集合  在這段索引範圍的arr[index]為待檢測的元素 \\((left \\leq\\) index \\(\u0026lt; right)\\)   index \\(\\in (-\\infty,\\ left)\\) → false集合  在這段索引範圍的arr[index]皆無法滿足condition函數(false) \\((-\\infty \u0026lt;\\) index \\(\u0026lt; left)\\)   index \\(\\in [right,\\ +\\infty)\\) → true集合  在這段索引範圍的arr[index]皆滿足condition函數(true) \\((right \\leq\\) index \\(\u0026lt; \\infty)\\)   定義完相關的循環不變量，接著就是照著規則實作  實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // The condition function bool condition(int val) { return (val \u0026gt;= 6); } int binarySearch(vector\u0026lt;int\u0026gt; \u0026amp;arr) { int left = 0, right = arr.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (condition(arr[mid]) == true) right = mid; else left = mid + 1; } if (left == arr.size()) printf(\u0026#34;Cannot find a valid element\\n\u0026#34;); return left; }     二元搜索執行之前 7  int left = 0, right = arr.size();  \n 待檢測集合為\\([0,\\ arr.size())\\)，因此left設定為0，right設定為arr.size()。 索引\\((-\\infty,\\ left) \\rightarrow (-\\infty,\\ 0)\\) 符合Loop invariant，在這個範圍condition(arr[index])皆為false。 索引\\([right,\\ \\infty) \\rightarrow [arr.size(),\\ \\infty)\\) 符合Loop invariant，在這個範圍condition(arr[index])皆為true。    二元搜索\n while迴圈的條件 9  while (left \u0026lt; right) {    還有尚未檢測的元素就要繼續執行，也就是待檢測集合: \\([left, right)\\) 至少有一個元素 \\((left \u0026lt; right)\\)   如果arr[mid]符合condition函數 12 13  if (condition(arr[mid]) == true) right = mid;    因為有前提的保證(所有true發生的位置必須落在所有false的右邊)，所以對於所有大於等於mid的索引調用condition函數都是true，而true集合範圍為\\([right,\\ \\infty)\\)，因此我們必須將right更新為mid。   arr[mid]不符合condition函數 14 15  else left = mid + 1;    因為有前提的保證(所有true發生的位置必須落在所有false的右邊)，所以對於所有小於等於mid的索引調用condition函數都是false，而false集合範圍為\\((-\\infty, left)\\)，因此我們必須將left更新為mid+1 (更新後我們可以確保left-1是原本的mid，而condition(arr[mid])為false)。      分析   收斂性\n 二元搜索法最怕的就是無窮迴圈(infinite loop)，而只要算法能夠在每次迴圈將待搜索範圍至少減一，就不會發生無窮迴圈。 在進入迴圈的時候，\\(left \u0026lt; right\\)，而且 \\(mid = \\frac{left + right}{2}\\) 用的是整數除法，所以這三個索引之間的關係是 \\(left \\leq mid \u0026lt; right\\)。 在迴圈中只有兩種索引更新，right = mid或是left = mid + 1，因為 right 不等於 mid ，所以right的更新會讓待搜索範圍至少減一，而left的更新也很明顯會讓待搜索範圍至少減一。 在搜索範圍為空集合時，迴圈的條件 \\(left \u0026lt; right\\) 不會滿足，因此不可能發生無窮迴圈    索引left和right\n 在結束了while迴圈，可以確定的是 \\(left \\geq right \\)，而透過以下分析我們可以知道其實 \\(left\\) 和 \\(right\\) 會指向同個地方  每次進入迴圈，三個索引之間的關係是 \\(left \\leq mid \u0026lt; right\\)，而且程式碼中只有兩種索引更新方式 right = mid: 執行完後的結果會是 \\(left \u0026lt; right\\ (left \\neq mid)\\) 或 \\(left = right\\ (left = mid)\\) left = mid + 1: 執行完後的結果會是 \\(left \u0026lt; right\\ (mid \u0026lt; right-1)\\) 或 \\(left = right\\ (mid = right-1)\\) 更新完索引之後如果 \\(left = right\\)，就會結束迴圈，所以不會有 \\(left \u0026gt; right \\) 的可能性。   left 和 right 指向的地方  從上面分析可以得出兩個索引最後會共同指向一個地方 從每次迴圈都維護的循環不變量false集合與true集合，我們可以分析  \\((-\\infty,\\ left)\\)為false集合，left和right共同指向的左側(不包含)condition皆為false。 \\([right,\\ \\infty)\\)為true集合，left和right共同指向的右側(包含)condition皆為true。   left 和 right 會共同指向滿足condition的最小索引      邊界條件分析\n 如果是空陣列(arr.size() = 0)， left 和 right 都會被初始化為 0，不會進到 while迴圈 如果陣列所有元素經過condition函數都是 false, left 和 right 最後會指到 arr.size()，代表找不到 如果陣列所有元素經過condition函數都是 true, left 和 right 都會指到 0    邊界條件處理\n 針對1. 2.兩種可能可以檢查left == arr.size()，再做對應處理    三種二元搜索法問題  接著要介紹的是三種常見的二元搜索法問題 幸運的是三種問題都可以從基本模板做稍微修改就可以解決。  尋找陣列中第一個6  目標: 給定一個升序排列的陣列arr，找出並回傳第一個6所在的位置，找不到則回傳-1\n   設計condition函數使得右半邊為true，左半邊為false\n1 2 3  bool condition(int val) { return (val \u0026gt;= 6); }     套用基本模板，找到第一個符合condition函數的位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int binarySearch(vector\u0026lt;int\u0026gt; \u0026amp;arr) { int left = 0, right = arr.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (condition(arr[mid])) right = mid; else left = mid + 1; } if (left == arr.size() || arr[left] != 6) return -1; return left; }    找到第一個大於等於6的位置之後  首先針對邊界條件做處理， left == arr.size() 代表找不到直接回傳-1。 如果有找到第一個大於等於6的元素，檢查是否是6， arr[left] == 6 ，不是就回傳-1，如果真的是6才回傳位置 left。      尋找陣列中最後一個6  目標: 給定一個升序排列的陣列arr，找出並回傳最後一個6所在的位置，找不到則回傳-1\n   設計condition函數使得右半邊為true，左半邊為false\n  但是這次要找得是最後一個6，所以我們稍微修改了一下condition函數，目標是找到第一個大於6的位置，再做後續處理\n1 2 3  bool condition(int val) { return (val \u0026gt; 6); }     套用基本模板，找到第一個大於6(符合condition函數)的位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  int binarySearch(vector\u0026lt;int\u0026gt; \u0026amp;arr) { int left = 0, right = arr.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (condition(arr[mid])) right = mid; else left = mid + 1; } if (left - 1 == -1 || arr[left - 1] != 6) return -1; return left - 1; }    找到第一個大於等於6的位置之後，我們想找得其實是最後一個6，所以要檢查得元素位置在 left - 1  首先針對邊界條件做處理，如果 left - 1 == -1 代表沒有最後一個小於等於6的元素，直接回傳-1。 如果有找到最後一個小於等於6的元素(位置 left - 1 ，第一個大於6的左邊)，檢查是否是6， arr[left - 1] == 6 ，不是就回傳-1，如果真的是6才回傳位置 left - 1。      尋找陣列中任一個6  目標: 給定一個升序排列的陣列arr，找出並回傳任一個6所在的位置，找不到則回傳-1\n   設計condition函數使得右半邊為true，左半邊為false\n  但是這次要找得是任一個6，原本condition函數定義為大於等於6，現在如果發現等於6就可以直接回傳位置了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  int binarySearch(vector\u0026lt;int\u0026gt; \u0026amp;arr) { int left = 0, right = arr.size(); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (arr[mid] == 6) return mid; else if (arr[mid] \u0026gt; 6) right = mid; else left = mid + 1; } return -1; }     Leetcode 相關題目 依照索引搜尋 (Search by Index)  Leetcode 35. Search Insert Position Leetcode 1146. Snapshot Array  依照範圍可能搜尋 (Search by space)  Leetcode 378. Kth Smallest Element in a Sorted Matrix Leetcode 410. Split Array Largest Sum Leetcode 878. Nth Magical Number Leetcode 1231. Divide Chocolate  ","date":"2022-01-30T18:15:41+08:00","image":"https://leovincentseles.github.io/posts/binary-search/LanYang-Museum_hud643287408cf45e84197812439608e3c_1378856_120x120_fill_q75_box_smart1.jpg","permalink":"https://leovincentseles.github.io/posts/binary-search/","title":"Introduction to Binary Search"},{"content":"C++ STL     queue priority_queue stack vector     insert back N/A N/A N/A push_back O(1) amortized   Insertion push O(1) push O(logN) push O(1) insert O(#inserted + #after)   Emplace emplace O(1) emplace O(logN) emplace O(1) emplace O(#after)   Deletion pop O(1) pop O(logN) pop O(1) erase O(#erased + #after)   Get Frist front O(1) top O(1) N/A front O(1)   Get Last back O(1) N/A top O(1) back O(1)   Is Empty empty O(1) empty O(1) empty O(1) empty O(1)   Size size O(1) size O(1) size O(1) size O(1)   Clear N/A N/A N/A clear O(N)        set unordered_set     Count count O(logN) count O(1) avg   O(N) worst     Insert insert O(logN) insert O(1) avg   O(N) worst     May rehash     Emplace emplace O(logN) emplace O(1) avg   O(N) worst     May rehash     Deletion (val) erase O(logN) erase O(1) avg   O(N) worst     Deletion (iterator) erase O(1) amortized erase O(1)   Deletion (range) erase O(#erased) erase O(#erased)   Find find O(logN) find O(1) avg   O(N) worst     Lower_bound lower_bound O(logN) N/A   Upper_bound upper_bound O(logN) N/A   Clear clear O(N) clear O(N)    deque   Implementation: matains a double-ended queue of chunks of fixed size.\n  provide a functionality similar to vector, but with efficient insertion and deletion of elements also at the beginning of the sequence.\n  queue   Default underlying container: deque, queue is not container, it just a container adapter.\n  push: Insert a new element at the end of the queue. (push_back of deque)\n  emplace: It can call the constructor by itself (more efficient). (emplace_back of deque)\n  pop: Removes the next element in the queue. (pop_front of deque)\n  front: Returns a reference to the next element in the queue. (front of deque)\n  back: Returns a reference to the last element in the queue. (back of deque)\n  empty: Returns whether the queue is empty. (empty of deque)\n  size: Returns the number of elements in the queue. (size of deque)\n1 2 3 4 5 6 7 8 9  class data { int a, b; public: data(int x, int y): a(x), b(y) {} }; queue\u0026lt;data\u0026gt; q; q.push(data(1, 2)); q.emplace(1, 2); // call constructor in place.     priority_queue  Default underlying container: vector  Requires indexing heavily. So choose the vector rather than the deque.   push: Insert a new element in the priority_queue. (push_back of vector, push_heap)  vector\u0026lt;int\u0026gt; arr, arr.push_back(3), push_heap(arr.begin(), arr.end())   emplace: emplace_back of vector, push_heap pop: Remove element on top of the priority queue. (pop_heap, pop_back of vector)  pop_heap(arr.begin(), arr.end()), arr.pop_back() pop_heap: swap the begin and end value, and makes the subrange [first, end-1) into a heap.   top: Return a constant reference to the top element. (front of vector) empty: Returns whether the priority_queue is empty. size: Returns the number of elements in the priority_queue.  stack  Default underlying container: deque, stack is not container, just a container adapter.  deque can grow faster than a vector (which requires reallocation and copying). stack will call push pop frequently, so choose the deque Reference: Why does stack use deque by default?   push: Insert a new element at the top of the stack. (push_back of deque) emplace: It can call the constructor by itself (more efficient). (emplace_back of deque) pop: Removes the element on top of the stack. (pop_back of deque) top: Returns a reference to the top element in the stack. (back of deque) empty: Returns whether the stack is empty. size: Returns the number of elements in the stack.  vector  back: Returns a reference to the last element in the vector. capacity: Return size of allocated storage capacity. emplace(iterator pos, element): Insert a new element at position. emplace_back(element): Construct and insert element at the end. push_back: Insert element at the end. insert: Insert an element at position.  insert(iterator pos, element): insert(iterator pos, iterator first, iterator last):  insert a range of element at the position.     erase: remove from the vector either a single element or a range.  erase(iterator pos): erase a single element from the position erase(iterator first, iterator last): erase a range of element [first, last)   pop_back: Removes the last element in the vector front: Returns a reference to the first element in the vector operator[]: Returns a reference to the element at position n in the vector container. begin, end: iterator point to before the first and after the last. rbegin, rend: reverse iterator point to before the last and one element before the first.  for (auto it=vector.rbegin(); it!=vector.rend(); ++it)   reserve: Request the vector capacity be at least enough to contain n elements  To prevent the frequent reallocation.   resize: Resizes the container so that it contains n elements.  resize(int n): If n is greater than current, call the default constructor. resize(int n, int val): If n is greater than current, the extended element is initialized with the provided value.    set   Sets are typically implemented as binary search tree to allow the direct iteration on subsets based on their order.\n Typically use the red-black tree. Some folks over at Google actucally builts a B-tree based containers.  Reference: Does any set implementation not use a red-black tree?      value_type is the first template parameter. (range based for loop)\n  count: 1 if the container contains an element, 0 otherwise\n  erase: Removes from the set container\n erase(iterator position): amortized O(1) erase(val): O(logN) erase(iterator first, iterator last): O(last-first)    insert: Insert the new elements to the set container\n insert(val): O(logN) insert(iterator first, iterator last): O(#inserted * logN)    find(val): search the container for an element equivalent to val.\n if found: Return the iterator to the element else: return the iterator set::end    lower_bound(val): Returns an iterator point to the first element ≥ val.\n  upper_bound(val): Returns an iterator point to the first element \u0026gt; val.\n  Traversal example:\n1 2 3 4 5 6 7 8 9  set\u0026lt;int\u0026gt; data; // range based traversal for (int num: data) cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; // Iterator traversal for (auto it=data.begin(); it!=data.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl;     unordered_set   Unordered sets are containers that store unique elements in no particular order.\n Use the hash table with bucket as the implementation. When the container is full may trigger rehash.    value_type is the first template parameter. (range based for loop)\n  count(k): 1 if an element with a value equivalent to k is found, or zero otherwise.\n  erase: Removes from the unordered_set container.\n erase(iterator position): O(1) erase(val): O(1) for avg, O(N) for worst erase(iterator first, iterator last): O(#erased)    insert: Inserts new elements in the unordered_set\n insert(val): O(1) for avg, O(N) for worst insert(iterator first, iterator last): O(inserted) for avg, O(N(size+1))* for worst    find(k): Searches the container for an element with k as value and returns an iterator.\n O(1) for constant, O(N) for worst    Traversal example\n1 2 3 4 5 6 7 8 9  unordered_set\u0026lt;int\u0026gt; data; // range based traversal for (int num: data) cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; // Iterator traversal for (auto it=data.begin(); it!=data.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl;     map   Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.\n  value_type is pair\u0026lt;const key_type, mapped_type\u0026gt; (range-based for loop)\n  operator[k]:\n If k matches the key of an element in the container, the function returns a reference to its mapped value. If k does not match the key of any element in the container, the function inserts a new element with that key (the element is constructed using its default constructor). and returns a reference to its mapped value.    Traversal example\n1 2 3 4 5 6 7 8 9 10 11 12 13  map\u0026lt;string, int\u0026gt; data; // range based traversal, (copy by value) for (auto mapPair: data) // for (pair\u0026lt;const string, int\u0026gt; mapPair: data) \tprintf(\u0026#34;%s, %d\\n\u0026#34;, mapPair.first, mapPair.second); // range based traversal (Use refernce directly) for (auto \u0026amp;mapPair: data) // for (pair\u0026lt;const string, int\u0026gt; \u0026amp;mapPair: data) \tprintf(\u0026#34;%s, %d\\n\u0026#34;, mapPair.first, mapPair.second); // Iterator traversal for (auto it=data.begin(); it!=data.end(); ++it) printf(\u0026#34;%s, %d\\n\u0026#34;, it-\u0026gt;first, it-\u0026gt;second);     unordered_map   Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value, and which allows for fast retrieval of indiviaudl elements based on their keys.\n  value_type is pair\u0026lt;const key_type, mapped_type\u0026gt; (range-based for loop)\n  operator[k]:\n If k matches the key of an element in the container, the function returns a reference to its mapped value. If k does not match the key of any element in the container, the function inserts a new element with that key (the element is constructed using its default constructor). and returns a reference to its mapped value.    Traversal example\n1 2 3 4 5 6 7 8 9 10 11 12 13  unordered_map\u0026lt;string, int\u0026gt; data; // range based traversal, (copy by value) for (auto mapPair: data) // for (pair\u0026lt;const string, int\u0026gt; mapPair: data) \tprintf(\u0026#34;%s, %d\\n\u0026#34;, mapPair.first, mapPair.second); // range based traversal (Use refernce directly) for (auto \u0026amp;mapPair: data) // for (pair\u0026lt;const string, int\u0026gt; \u0026amp;mapPair: data) \tprintf(\u0026#34;%s, %d\\n\u0026#34;, mapPair.first, mapPair.second); // Iterator traversal for (auto it=data.begin(); it!=data.end(); ++it) printf(\u0026#34;%s, %d\\n\u0026#34;, it-\u0026gt;first, it-\u0026gt;second);     list  Get Reference:  front(), back()   Get Iterator:  begin(), end()   Deletion:  erase(iterator position) erase(iterator first, iterator last) Iterators, pointers and references referring to elements removed by the function are invalidated. All other iterators, pointers and reference keep their validity.   Insertion:  insert(iterator position, value) insert(iterator position, size_type n, val) insert(iterator position, iterator first, iterator last)   pop_back(), pop_front(), push_back(), push_front() reverse  ","date":"2022-01-30T10:17:40+08:00","permalink":"https://leovincentseles.github.io/posts/stl/","title":"STL"}]