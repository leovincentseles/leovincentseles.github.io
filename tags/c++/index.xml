<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on Yin-Chiuan Chen</title><link>https://leovincentseles.github.io/tags/c++/</link><description>Recent content in C++ on Yin-Chiuan Chen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 30 Jan 2022 18:15:41 +0800</lastBuildDate><atom:link href="https://leovincentseles.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Binary Search</title><link>https://leovincentseles.github.io/posts/binary-search/</link><pubDate>Sun, 30 Jan 2022 18:15:41 +0800</pubDate><guid>https://leovincentseles.github.io/posts/binary-search/</guid><description>介紹 二元搜索法 (Binary Search) 是大家剛接觸程式設計就學習到的演算法，但是一點也不簡單，是標準的一看就會一寫就廢類型 (引自代碼隨想錄)，寫不好的原因有兩個 區間的定義 [left, right], [left, right), (left, right], (left, right) left, right 兩個索引在算法執行前、執行中與執行後後分別會指向哪種元素? 這篇文章將會描述二元搜索法的算法模板，以及介紹三種常見的二元搜索法問題 基本模板 模板是讀了jiah在Leetcode討論區下方的留言之後整理出來 先討論二元搜索法的基本模板，後續才會說明如何利用模板轉換成三種常見的二元搜索法問題 基本模板說明 目標: 給定一個陣列arr，找出最小的索引k，使得condition(arr[k])結果為true。
舉個例子: 找出陣列中第一個大於等於6的元素，
用基本模板說明就是找出陣列中最小的索引k，而且arr[k] ≥ 6 (condition函數)
在這個例子(下方程式碼)中我們想要的k就是2 (因為arr[2] ≥ 6)
1 2 3 4 5 6 7 // The given array vector&amp;lt;int&amp;gt; arr{1, 5, 7, 20}; // The condition function bool condition(int val) { return (val &amp;gt;= 6); } 在更深入討論基本模板之前，我們需要先了解模板的使用前提，並設計適當的condition函數</description></item></channel></rss>